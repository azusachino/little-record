# 左耳听风

## RTFM: Read The Fucking Manual

完全没有必要通过打工听人安排而活着，而是反过来通过在公司工作提高自己的技能，让自己可以更为独立和自由地生活。

- 要去经历大多数人经历不到的，要把学习时间花在那些比较难的地方。
- 要写文章就要写没有人写过的，或是别人写过，但我能写得更好的。
- 更重要的是，技术和知识完全是可以变现的。

### 程序员必备的素质

- 扎实的基础技术；
- 非同一般的学习能力；
- 坚持做正确的事；
- 不断得高对自己的要求标准；
- 关注市场需求、技术趋势。

### 技术领导力

- 尊重技术，追求核心基础技术。
- 追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。
- 解放生产力，追逐人效的提高。
- 开发抽象和高质量的可以重用的技术组件。
- 坚持高于社会主流的技术标准和要求。

---

### 工程师的特质

- **能够发现问题**。能够发现现有方案的问题。
- **能够提供解决问题的思路和方案，并能比较这些方案的优缺点**。
- **能够做出正确的技术决定**。用什么样的技术、什么解决方案、怎样实现来完成一个项目。
- **能够用更优雅，更简单，更容易的方式来解决问题**。
- **能够提高代码或软件的扩展性、重用性和可维护性**。
- **能够用正确的方式管理团队**。所谓正确的方式，一方面是，让正确的人做正确的事，并发挥每个人的潜力；另一方面是，可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。
- **创新能力**。能够使用新的方法新的方式解决问题，追逐新的工具和技术。

### 编程和系统

- C 语言：学习好 C 语言的好处是能掌握程序的运行情况，并能进行应用程序和操作系统编程
- 编程范式：学好编程范式，有助于培养你的抽象思维，同时也可以提高编程效率，提高程序的结构合理性、可读性和可维护性，降低代码的冗余度，进而提高代码的运行效率。
- 算法和数据结构：算法（及其相应的数据结构）是程序设计的有力支撑。适当地应用算法，可以有效地抽象问题，提高程序的合理性和执行效率。算法是编程中最最重要的东西，也是计算机科学中最重要的基础。
- 计算机系统原理：CPU 的体系结构（指令集 [CISC/RISC]、分支预测、缓存结构、总线、DMA、中断、陷阱、多任务、虚拟内存、虚拟化等），内存的原理与性能特点（SRAM、DRAM、DDR-SDRAM 等），磁盘的原理（机械硬盘 [盘面、磁头臂、磁头、启停区、寻道等]、固态硬盘 [页映射、块的合并与回收算法、TRIM 指令等]），GPU 的原理等。《深入理解计算机系统》
- 操作系统原理和基础：进程、进程管理、线程、线程调度、多核的缓存一致性、信号量、物理内存管理、虚拟内存管理、内存分配、文件系统、磁盘管理等。《UNIX 环境高级编程》《UNIX 网络编程》《Windows 核心编程》
- 网络基础：需要了解基本的网络层次结构（ISO/OSI 模型、TCP/IP 协议栈），包括物理层、数据链路层（包含错误重发机制）、网络层（包含路由机制）、传输层（包含连接保持机制）、会话层、表示层、应用层（在 TCP/IP 协议栈里，这三层可以并为一层）。
- 数据库原理：了解数据库访问性能调优的要点，以及保证并发情况下数据操作原子性的方法。
- 分布式技术架构：学习分布式技术架构，包括负载均衡、DNS 解析、多子域名、无状态应用层、缓存层、数据库分片、容错和恢复机制、Paxos、Map/Reduce 操作、分布式 SQL 数据库一致性（以 Google Cloud Spanner 为代表）等知识点。

---

- 提高效率的事
- 自动化的事
- 掌握前沿技术的事
- 知识密集型的事
- 技术驱动的事

### 每个程序员都应该读的书

- **《代码大全》**  虽然这本书有点过时了，而且厚到可以垫显示器，但是这绝对是一本经典的书。
- **《程序员修练之道》**  这本书也是相当经典，我觉得就是你的指路明灯。
- **《计算机的构造和解释》**  经典中的经典，必读。
- **《算法导论》**  美国的本科生教材，这本书应该也是中国计算机学生的教材。
- **《设计模式》**  这本书是面向对象设计的经典书籍。
- **《重构》**  代码坏味道和相应代码的最佳实践。
- **《人月神话》**  这本书可能也有点过时了。但还是经典书。
- **《代码整洁之道》**  细节之处的效率，完美和简单。
- **《Effective C++》/《More Effective C++》** C++ 中两本经典得不能再经典的书。也许你觉得 C++ 复杂，但这两本书中带来对代码稳定性的探索方式让人受益，因为这种思维方式同样可以用在其它地方。以至于各种模仿者，比如《Effective Java》也是一本经典书。
- **《Unix 编程艺术》、《Unix 高级环境编程》**也是相关的经典。

工程类数学、Unix 哲学和实践、系统管理、程序设计语言、离散数学、数据结构与算法、计算机体系结构、操作系统、网络、安全、密码学、软件测试、用户体验、可视化、并行计算、软件工程、形式化方法、图形学、机器人、人工智能、机器学习、数据库等等。

---

1. **客观地审视自己**。找到自己的长处，不断地在自己的长处上发展自我。知道自己几斤几两才能清楚自己适合干什么。不然，目标设置得过高自己达不到，反而让自己难受。在职场上，审视自己的最佳方式，就是隔三差五就出去面试一把，看看自己在市场上能够到什么样的级别。**如果你超过了身边的大多数人，你不妨选择得激进一些冒险一些，否则，还是按部就班地来吧**。
2. **确定自己想要什么**。如果不确定这个事，你就会纠结，不知道自己要什么，也就不知道自己要去哪里。注意，你不可能什么都要，你需要极端地知道自己要什么。**所谓“极端”，就是自己不会受到其它东西或其他人的影响，不会因为这条路上有人退出你会开始怀疑或者迷茫，也不会因为别的路上有人成功了，你就会羡慕**。
3. **注重长期的可能性，而不是短期的功利**。20-30 岁应该多去经历一些有挑战的事，多去选择能给自己带来更多可能性的事。多去选择能让自己成长的事，尤其是能让自己开阔眼界的事情。人最害怕的不是自己什么都不会，而是自己不知道自己不会。
4. **尽量关注自己会得到的东西，而不是自己会失去的东西**。因为无论你怎么选，你都会有得有失。（绝大多数人都会考虑自己会失去的，而不是考虑自己会得到的。）
5. **不要和大众的思维方式一样**。因为，绝大多数人都是平庸的，所以，如果你的思维方式和大众一样，这意味着你做出来的选择也会和大众一样平庸。如果你和大众不一样，那么只有两种情况，一个是你比大多数人聪明，一个是你比大多数人愚蠢。

### Leader 的素质

1. 赢得他人的信任
2. 开放的心态+倾向性的价值观
3. Lead By example
4. 保持热情和冲动
5. 能够抓住重点，看透事物的本质
6. 描绘令人激动的方向，提供令人向往的环境
7. 甘当铺路石，为他人创造机会

---

### 错误的种类

- **资源的错误**。当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的文件，写文件时出现的写错误，发送文件到网络端发现网络故障的错误，等等。**这一类错误属于程序运行环境的问题。对于这类错误，有的我们可以处理，有的我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源不能满足等等这些情况，我们只能停止运行，甚至退出整个程序。**
- **程序的错误**。比如：空指针、非法参数等。**这类是我们自己程序的错误，我们要记录下来，写入日志，最好触发监控系统报警**。
- **用户的错误**。比如：Bad Request, Bad Format 等这类由用户不合法输入带来的错误。**这类错误基本上是在用户的 API 层上出现的问题**。比如，解析一个 XML 或 JSON 文件，或是用户输入的字段不合法之类的。**对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。然后，我们正常执行，但是需要做统计，统计相应的错误率，这样有利于我们改善软件或是侦测是否有恶意的用户请求。**

```cpp
// 异常时的资源管理
std::mutex m;

void bad()
{
    m.lock();                    // 请求互斥
    f();                         // 若 f() 抛异常，则互斥绝不被释放
    if(!everything_ok)) return; // 提早返回，互斥绝不被释放
    m.unlock();                  // 若 bad() 抵达此语句，互斥才被释放
}

// 首先，先声明一个 RAII 类，注意其中的构造函数和析构函数
class LockGuard {
public:
	LockGuard(std::mutex &m):_m(m) { m.lock(); }
	~LockGuard() { m. unlock(); }
private:
	std::mutex& _m;
}

// 然后，我们来看一下，怎样使用的
void good()
{
	LockGuard lg(m);   // RAII 类：构造时，互斥量请求加锁
	f();                             // 若 f() 抛异常，则释放互斥
	if(!everything_ok()) return;     // 提早返回，LockGuard 析构时，互斥量被释放
}
```

## 异步编程的错误处理

- **无法使用返回码**。因为函数在“被”异步运行中，所谓的返回只是把处理权交给下一条指令，而不是把函数运行完的结果返回。**所以，函数返回的语义完全变了，返回码也没有用了**。
- **无法使用抛异常的方式**。因为除了上述的函数立马返回的原因之外，抛出的异常也在另外一个线程中，不同线程中的栈是完全不一样的，所以主线程的  `catch`  完全看不到另外一个线程中的异常。

```jsx
doSomething(function (result) {
  doSomethingElse(
    result,
    function (newResult) {
      doThirdThing(
        newResult,
        function (finalResult) {
          console.log("Got the final result: " + finalResult);
        },
        failureCallback
      );
    },
    failureCallback
  );
}, failureCallback);

doSomething() // 使用Promise
  .then((res) => doSomethingElse(res))
  .then((newRes) => doThirdThing(newRes))
  .then((finalRes) => {
    console.log(`got the final result: ${finalRes}`);
  })
  .catch(failureCallback);

async function foo() {
  try {
    let res = await doSomething();
    let newRes = await doSomethingElse(res);
    let finalRes = await doThirdThing(newRes);
    console.log(`got the final result: ${finalRes}`);
  } catch (error) {
    failureCallback(error);
  }
}
```

```java
CompletableFuture.supplyAysnc(this::findReceiver)
                 .thenApply(this::sendMsg)
                 .thenAccept(this::notify);
CompletableFuture.supplyAsync(Integer::parseInt) // 输入: "ILLEGAL"
			     .thenApply(r -> r * 2 * Math.PI)
			     .thenApply(s -> "apply>> " + s)
			     .exceptionally(ex -> "Error: " + ex.getMessage());
CompletableFuture.supplyAsync(Integer::parseInt) // 输入: "ILLEGAL"
				 .thenApply(r -> r * 2 * Math.PI)
				 .thenApply(s -> "apply>> " + s)
				 .handle((result, ex) -> {
				 	if (result != null) {
				 		return result;
				 	} else {
				 		return "Error handling: " + ex.getMessage();
				 	}
				 });
```

### 错误处理的最佳实践

- **统一分类的错误字典**。无论你是使用错误码还是异常捕捉，都需要认真并统一地做好错误的分类。最好是在一个地方定义相关的错误。比如，HTTP 的 4XX 表示客户端有问题，5XX 则表示服务端有问题。也就是说，你要建立一个错误字典。
- **同类错误的定义最好是可以扩展的**。这一点非常重要，而对于这一点，通过面向对象的继承或是像 Go 语言那样的接口多态可以很好地做到。这样可以方便地重用已有的代码。
- **定义错误的严重程度**。比如，Fatal 表示重大错误，Error 表示资源或需求得不到满足，Warning 表示并不一定是个错误但还是需要引起注意，Info 表示不是错误只是一个信息，Debug 表示这是给内部开发人员用于调试程序的。
- **错误日志的输出最好使用错误码，而不是错误信息**。打印错误日志的时候，应该使用统一的格式。但最好不要用错误信息，而应使用相应的错误码，错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件进行自动化监控，而不是要从错误信息中做语义分析。比如：HTTP 的日志中就会有 HTTP 的返回码，如：`404`。但我更推荐使用像`PageNotFound`这样的标识，这样人和机器都很容易处理。
- **忽略错误最好有日志**。不然会给维护带来很大的麻烦。
- **对于同一个地方不停的报错，最好不要都打到日志里**。不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。
- **不要用错误处理逻辑来处理业务逻辑**。也就是说，不要使用异常捕捉这样的方式来处理业务逻辑，而是应该用条件判断。如果一个逻辑控制可以用 if - else 清楚地表达，那就不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事情，而错误码则用来处理可能会发生的事。
- **对于同类的错误处理，用一样的模式**。比如，对于`null`对象的错误，要么都用返回 null，加上条件检查的模式，要么都用抛 NullPointerException 的方式处理。不要混用，这样有助于代码规范。
- **尽可能在错误发生的地方处理错误**。因为这样会让调用者变得更简单。
- **向上尽可能地返回原始的错误**。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。
- **处理错误时，总是要清理已分配的资源**。这点非常关键，使用 RAII 技术，或是 try-catch-finally，或是 Go 的 defer 都可以容易地做到。
- **不推荐在循环体里处理错误**。这里说的是 try-catch，绝大多数的情况你不需要这样做。最好把整个循环体外放在 try 语句块内，而在外面做 catch。
- **不要把大量的代码都放在一个 try 语句块内**。一个 try 语句块内的语句应该是完成一个简单单一的事情。
- **为你的错误定义提供清楚的文档以及每种错误的代码示例**。如果你是做 RESTful API 方面的，使用 Swagger 会帮你很容易搞定这个事。
- **对于异步的方式，推荐使用 Promise 模式处理错误**。对于这一点，JavaScript 中有很好的实践。
- **对于分布式的系统，推荐使用 APM 相关的软件**。尤其是使用 Zipkin 这样的服务调用跟踪的分析来关联错误。

### 魔数 0x5f3759df

```cpp
float Q_rsqrt( float number )
{
    long i;
    float x2, y;
    const float threehalfs = 1.5F;

    x2 = number * 0.5F;
    y  = number;
    i  = * ( long * ) &y; // evil floating point bit level hacking
    i  = 0x5f3759df - ( i >> 1 );  // what the fuck?
    y  = * ( float * ) &i;
    y  = y * ( threehalfs - ( x2 * y * y ) );  // 1st iteration
    // 2nd iteration, this can be removed
    // y  = y * ( threehalfs - ( x2 * y * y ) );

    return y;
}
```

### 机器学习入门知识

对于监督式学习，有如下经典算法。

1. 决策树（Decision Tree）。比如自动化放贷、风控。
2. 朴素贝叶斯分类（Naive Bayesian classification）。可以用于判断垃圾邮件，对新闻的类别进行分类，比如科技、政治、运动，判断文本表达的感情是积极的还是消极的，以及人脸识别等。
3. 最小二乘法（Ordinary Least Squares Regression）。算是一种线性回归。
4. 逻辑回归（Logisitic Regression）。一种强大的统计学方法，可以用一个或多个变量来表示一个二项式结果。它可以用于信用评分、计算营销活动的成功率、预测某个产品的收入等。
5. 支持向量机（Support Vector Machine，SVM）。可以用于基于图像的性别检测，图像分类等。
6. 集成方法（Ensemble methods）。通过构建一组分类器，然后根据它们的预测结果进行加权投票来对新的数据点进行分类。原始的集成方法是贝叶斯平均，但是最近的算法包括纠错输出编码、Bagging 和 Boosting。

对于非监督式的学习，有如下经典算法。

1. 聚类算法（Clustering Algorithms）。聚类算法有很多，目标是给数据分类。
2. 主成分分析（Principal Component Analysis，PCA）。PCA 的一些应用包括压缩、简化数据，便于学习和可视化等。
3. 奇异值分解（Singular Value Decomposition，SVD）。实际上，PCA 是 SVD 的一个简单应用。在计算机视觉中，第一个人脸识别算法使用 PCA 和 SVD 来将面部表示为“特征面”的线性组合，进行降维，然后通过简单的方法将面部匹配到身份。虽然现代方法更复杂，但很多方面仍然依赖于类似的技术。
4. 独立成分分析（Independent Component Analysis，ICA）。ICA 是一种统计技术，主要用于揭示随机变量、测量值或信号集中的隐藏因素。

### 时间管理

- 花时间学习基础知识，花时间读文档
- 花时间在解放自己生产力的事上
- 花时间在让自己成长的事上
- 花时间在建立高效的环境上
- 定义好优先级
- 最短作业优先
- 想清楚再做
- 关注长期利益规划
- 将军赶路不追小兔
- 形成习惯
- 形成正反馈
- 反思和举一反三

### 故障处理

1. 重启和限流
2. 回滚操作
3. 降级操作
4. 紧急更新

**故障前的准备工作**

- 以用户功能为索引的服务和资源的全视图
- 为地图中的各个服务指定关键指标，以及一套运维流程和工具，包括应急方案
- 设计故障的等级
- 故障演练
- 灰度发布系统

**故障复盘过程**

- **故障处理的整个过程**。就像一个 log 一样，需要详细地记录几点几分干了什么事，把故障从发生到解决的所有细节过程都记录下来。
- **故障原因分析**。需要说明故障的原因和分析报告。
- **Ask 5 Whys**。需要反思并反问至少 5 个为什么，并为这些“为什么”找到答案。
- **故障后续整改计划**。需要针对上述的“Ask 5 Whys”说明后续如何举一反三地从根本上解决所有的问题。

**故障整改方法**

第一，优化故障获知和故障定位的时间。

- 从故障发生到我们知道的时间是否可以优化得更短？
- 定位故障的时间是否可以更短？
- 有哪些地方可以做到自动化？

第二，优化故障的处理方式。

- 故障处理时的判断和章法是否科学，是否正确？
- 故障处理时的信息是否全透明？
- 故障处理时人员是否安排得当？

第三，优化开发过程中的问题。

- Code Review 和测试中的问题和优化点。
- 软件架构和设计是否可以更好？
- 对于技术欠债或是相关的隐患问题是否被记录下来，是否有风险计划？

第四，优化团队能力。

- 如何提高团队的技术能力？
- 如何让团队有严谨的工程意识？

1. **举一反三解决当下的故障**。为自己赢得更多的时间。
2. **简化复杂、不合理的技术架构、流程和组织**。你不可能在一个复杂的环境下根本地解决问题。
3. **全面改善和优化整个系统，包括组织**。解决问题的根本方法是改善和调整整体结构。而只有简单优雅的东西才有被改善和优化的可能。

### 分布式架构

1. 提高整体架构的吞吐量，服务更多的并发和流量
2. 提高系统的稳定性，让系统的可用性更高

**分布式带来的问题**

- 架构设计变得复杂（尤其是其中的分布式事务）。
- 部署单个服务会比较快，但是如果一次部署需要多个服务，流程会变得复杂。
- 系统的吞吐量会变大，但是响应时间会变长。
- 运维复杂度会因为服务变多而变得很复杂。
- 架构复杂导致学习曲线变大。
- 测试和查错的复杂度增大。
- 技术多元化，这会带来维护和运维的复杂度。
- 管理分布式系统中的服务和调度变得困难和复杂。

**分布式系统中需要注意的问题**

1. 异构系统的不标准问题
2. 系统架构中的服务依赖性问题
3. 故障发生的概率更大
4. 多层架构的运维复杂度更大

**四层系统**

- 基础层就是我们的机器、网络和存储设备等。
- 平台层就是我们的中间件层，Tomcat、MySQL、Redis、Kafka 之类的软件。
- 应用层就是我们的业务软件，比如，各种功能的服务。
- 接入层就是接入用户请求的网关、负载均衡或是 CDN、DNS 这样的东西。

**提升架构的性能**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b79f9686-c83d-4cc3-90d1-ad7d1f90ef34/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b79f9686-c83d-4cc3-90d1-ad7d1f90ef34/Untitled.png)

- **缓存系统**。加入缓存系统，可以有效地提高系统的访问能力。从前端的浏览器，到网络，再到后端的服务，底层的数据库、文件系统、硬盘和 CPU，全都有缓存，这是提高快速访问能力最有效的手段。对于分布式系统下的缓存系统，需要的是一个缓存集群。这其中需要一个 Proxy 来做缓存的分片和路由。
- **负载均衡系统**。负载均衡系统是水平扩展的关键技术，它可以使用多台机器来共同分担一部分流量请求。
- **异步调用**。异步系统主要通过消息队列来对请求做排队处理，这样可以把前端的请求的峰值给“削平”了，而后端通过自己能够处理的速度来处理请求。这样可以增加系统的吞吐量，但是实时性就差很多了。同时，还会引入消息丢失的问题，所以要对消息做持久化，这会造成“有状态”的结点，从而增加了服务调度的难度。
- **数据分区和数据镜像**。**数据分区**是把数据按一定的方式分成多个区（比如通过地理位置），不同的数据区来分担不同区的流量。这需要一个数据路由的中间件，会导致跨库的 Join 和跨库的事务非常复杂。而**数据镜像**是把一个数据库镜像成多份一样的数据，这样就不需要数据路由的中间件了。你可以在任意结点上进行读写，内部会自行同步数据。然而，数据镜像中最大的问题就是数据的一致性问题。

**提高架构的稳定性**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b388b13d-f301-4d72-91fe-6732e164b9e0/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b388b13d-f301-4d72-91fe-6732e164b9e0/Untitled.png)

- **服务拆分**。服务拆分主要有两个目的：一是为了隔离故障，二是为了重用服务模块。但服务拆分完之后，会引入服务调用间的依赖问题。
- **服务冗余**。服务冗余是为了去除单点故障，并可以支持服务的弹性伸缩，以及故障迁移。然而，对于一些有状态的服务来说，冗余这些有状态的服务带来了更高的复杂性。其中一个是弹性伸缩时，需要考虑数据的复制或是重新分片，迁移的时候还要迁移数据到其它机器上。
- **限流降级**。当系统实在扛不住压力时，只能通过限流或者功能降级的方式来停掉一部分服务，或是拒绝一部分用户，以确保整个架构不会挂掉。这些技术属于保护措施。
- **高可用架构**。通常来说高可用架构是从冗余架构的角度来保障可用性。比如，多租户隔离，灾备多活，或是数据可以在其中复制保持一致性的集群。总之，就是为了不出单点故障。
- **高可用运维**。高可用运维指的是 DevOps 中的 CI/CD（持续集成 / 持续部署）。一个良好的运维应该是一条很流畅的软件发布管线，其中做了足够的自动化测试，还可以做相应的灰度发布，以及对线上系统的自动化控制。这样，可以做到“计划内”或是“非计划内”的宕机事件的时长最短。

**分布式系统的关键技术**

- **服务治理**。服务拆分、服务调用、服务发现、服务依赖、服务的关键度定义……服务治理的最大意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。
- **架构软件管理**。服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。
- **DevOps**。分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。
- **自动化运维**。有了 DevOps 后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。
- **资源调度管理**。应用层的自动化运维需要基础层的调度支持，也就是云计算 IaaS 层的计算、存储、网络等资源调度、隔离和管理。
- **整体架构监控**。如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛，没有数据，就无法进行高效的运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。
- **流量控制**。最后是我们的流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7a9cdc03-4c09-4acf-8322-274743b1111f/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7a9cdc03-4c09-4acf-8322-274743b1111f/Untitled.png)

### 全栈监控

- **基础层**：监控主机和底层资源。比如：CPU、内存、网络吞吐、硬盘 I/O、硬盘使用等。
- **中间层**：就是中间件层的监控。比如：Nginx、Redis、ActiveMQ、Kafka、MySQL、Tomcat 等。
- **应用层**：监控应用层的使用。比如：HTTP 访问的吞吐量、响应时间、返回码，调用链路分析，性能瓶颈，还包括用户端的监控。

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6e907980-8583-4f8e-9a81-003e0c46011d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6e907980-8583-4f8e-9a81-003e0c46011d/Untitled.png)

**标准化的监控**

- 日志数据结构化；
- 监控数据格式标准化；
- 统一的监控平台；
- 统一的日志分析。

**监控系统功能**

- 服务调用链路跟踪
- 服务调用时长分布
- 服务的 topN 视图：a）按调用量排名，b) 按请求最耗时排名，c）按热点排名
- 数据库操作关联
- 服务资源跟踪

流量调度的关键技术

1. **高性能**。API Gateway 必须使用高性能的技术，所以，也就需要使用高性能的语言。
2. **扛流量**。要能扛流量，就需要使用集群技术。集群技术的关键点是在集群内的各个结点中共享数据。这就需要使用像 Paxos、Raft、Gossip 这样的通讯协议。因为 Gateway 需要部署在广域网上，所以还需要集群的分组技术。
3. **业务逻辑**。API Gateway 需要有简单的业务逻辑，所以，最好是像 AWS 的 Lambda 服务一样，可以让人注入不同语言的简单业务逻辑。
4. **服务化**。一个好的 API Gateway 需要能够通过 Admin API 来不停机地管理配置变更，而不是通过一个.conf 文件来人肉地修改配置。

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/35d39f83-0f84-4613-8968-315419c0916f/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/35d39f83-0f84-4613-8968-315419c0916f/Untitled.png)

- 提高服务的 SLA
- 能力和资源重用或复用
- 过程的自动化

### PAAS

- **服务化是 PaaS 的本质**。软件模块重用，服务治理，对外提供能力是 PaaS 的本质。
- **分布式是 PaaS 的根本特性**。多租户隔离、高可用、服务编排是 PaaS 的基本特性。
- **自动化是 PaaS 的灵魂**。自动化部署安装运维，自动化伸缩调度是 PaaS 的关键。

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4dbe20da-c067-4807-9bf8-dad371b3a4aa/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4dbe20da-c067-4807-9bf8-dad371b3a4aa/Untitled.png)

- PaaS 调度层 – 主要是 PaaS 的自动化和分布式对于高可用高性能的管理。
- PaaS 能力服务层 – 主要是 PaaS 真正提供给用户的服务和能力。
- PaaS 的流量调度 – 主要是与流量调度相关的东西，包括对高并发的管理。
- PaaS 的运营管理 – 软件资源库、软件接入、认证和开放平台门户。
- PaaS 的运维管理 – 主要是 DevOps 相关的东西。

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/194c047a-a313-4246-bd5a-d1c4128a8454/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/194c047a-a313-4246-bd5a-d1c4128a8454/Untitled.png)

传统的单体架构系统容量显然是有上限的。同时，为了应对有计划和无计划的下线时间，系统的可用性也是有其极限的。分布式系统为以上两个问题提供了解决方案，并且还附带有其他优势。但是，要同时解决这两个问题决非易事。为了构建分布式系统，我们面临的主要问题如下。

- 分布式系统的硬件故障发生率更高，故障发生是常态，需要尽可能地将运维流程自动化。
- 需要良好地设计服务，避免某服务的单点故障对依赖它的其他服务造成大面积影响。
- 为了容量的可伸缩性，服务的拆分、自治和无状态变得更加重要，可能需要对老的软件逻辑做大的修改。
- 老的服务可能是异构的，此时需要让它们使用标准的协议，以便可以被调度、编排，且互相之间可以通信。
- 服务软件故障的处理也变得复杂，需要优化的流程，以加快故障的恢复。
- 为了管理各个服务的容量，让分布式系统发挥出最佳性能，需要有流量调度技术。
- 分布式存储会让事务处理变得复杂；在事务遇到故障无法被自动恢复的情况下，手动恢复流程也会变得复杂。
- 测试和查错的复杂度增大。
- 系统的吞吐量会变大，但响应时间会变长。

为了解决这些问题，我们深入了解了以下这些解决方案。

- 需要有完善的监控系统，以便对服务运行状态有全面的了解。
- 设计服务时要分析其依赖链；当非关键服务故障时，其他服务要自动降级功能，避免调用该服务。
- 重构老的软件，使其能被服务化；可以参考 SOA 和微服务的设计方式，目标是微服务化；使用 Docker 和 Kubernetes 来调度服务。
- 为老的服务编写接口逻辑来使用标准协议，或在必要时重构老的服务以使得它们有这些功能。
- 自动构建服务的依赖地图，并引入好的处理流程，让团队能以最快速度定位和恢复故障，详见《故障处理最佳实践：应对故障》一文。
- 使用一个 API Gateway，它具备服务流向控制、流量控制和管理的功能。
- 事务处理建议在存储层实现；根据业务需求，或者降级使用更简单、吞吐量更大的最终一致性方案，或者通过二阶段提交、Paxos、Raft、NWR 等方案之一，使用吞吐量小的强一致性方案。
- 通过更真实地模拟生产环境，乃至在生产环境中做灰度发布，从而增加测试强度；同时做充分的单元测试和集成测试以发现和消除缺陷；最后，在服务故障发生时，相关的多个团队同时上线自查服务状态，以最快地定位故障原因。
- 通过异步调用来减少对短响应时间的依赖；对关键服务提供专属硬件资源，并优化软件逻辑以缩短响应时间。
