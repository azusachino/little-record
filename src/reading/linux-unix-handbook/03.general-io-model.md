# 文件 I/O：通用的 I/O 模型

- 打开文件
- 关闭文件
- 从文件中读取数据
- 向文件中写数据

## I/O 概述

所有执行 I/O 操作的系统调用都以文件描述符，一个非负整数，来指代打开的文件。文件描述符用以表示所有类型的已打开文件，包括管道、FIFO、socket、终端设备和普通文件。

| 文件描述符 | 用途     | POSIX 名称    | stdio 流 |
| ---------- | -------- | ------------- | -------- |
| 0          | 标准输入 | STDIN_FILENO  | stdin    |
| 1          | 标准输出 | STDOUT_FILENO | stdout   |
| 2          | 标准错误 | STDERR_FILENO | stderr   |

在程序开始运行之前，shell 代表程序打开上述三种文件描述符。【更准确地说，程序继承了 shell 文件描述符副本；在 shell 的正常操作中，这三个文件描述符始终是打开的】

### 4 个主要系统调用

- `fd = open(pathname, flags, mode)` 函数打开 pathname 所标识的文件，并返回文件描述符，用于在后续函数调用中指代打开的文件。
- `num_read = read(fd, buffer, count)` 调用从 fd 指代的打开文件中读取至多 count 字节的数据，并存储到 buffer 中。`read()` 调用的返回值为实际读取到的字节数。如果再无字节可读【EOF】，返回值为 0。
- `num_written = write(fd, buffer, count)` 调用从 buffer 中读取多大 count 字节的数据写入由 fd 所指代的已打开文件中。 `write()` 调用的返回值为实际写入文件中的字节数，，可能小于 count。
- `status = close(fd)` 在所有输入/输出操作完成后，调用 `close()`，释放文件描述符 fd 以及与之相关的内核资源。

使用 I/O 系统调用实现 copy 操作：

```c
#include <sys/stat.h>
#include <fcntl.h>
#include "tlpi_hdr.h"

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif

/* copy.c

   Copy the file named argv[1] to a new file named in argv[2].
*/
int main(int argc, char *argv[])
{
    int inputFd, outputFd, openFlags;

    mode_t filePerms;
    ssize_t numRead;
    char buf[BUFFER_SIZE];

    if (argc != 3 || strcpm(argv[1], "--help") == 0)
    {
        usageErr("%s old-file new-file\n", argv[0]);
    }

    inputFd = open(argv[1], O_RDONLY);
    if (inputFd == -1)
    {
        errExit("opening file %s", argv[1]);
    }
    /* create, readonly, truncate */
    openFlags = O_CREAT | O_WRONLY | O_TRUNC;
    /* rw-rw-rw */
    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
    outputFd = open(argv[2], openFlags, filePerms);
    if (outputFd == -1)
    {
        errExit("opening file %s", argv[2]);
    }

    /* Transfer data until we encounter end of input or an error */
    while ((numRead = read(inputFd, buf, BUFFER_SIZE)) > 0)
    {
        if (write(outputFd, buf, numRead) != numRead)
        {
            fatal("write() returned error or partial write occurred");
        }
    }
    if (numRead == -1)
    {
        errExit("read failed");
    }

    if (close(inputFd) == -1)
    {
        errExit("close input fd");
    }
    if (close(outputFd) == -1)
    {
        errExit("close output fd");
    }

    exit(EXIT_SUCCESS);
}
```

## 通用 I/O

UNIX I/O 模型的显著特点之一是其输入/输出的通用性概念。仅使用这些系统调用编写的程序，将对任何类型的文件有效。

```sh
./copy test test.old # copy a regular file
./copy a.txt /dev/tty # copy a regular file to this terminal
./copy /dev/tty b.txt # copy input from this terminal to a regular file
./copy /dev/pts/16 /dev/tty # copy input from another terminal
```

## open

`open()` 调用既能打开一个已存在的文件，也能创建并打开一个新文件。

```c
#include <sys/stat.h>
#include <fcntl.h>

int open(const char* pathname, int flags, ... /* mode_t mode */);
```

### 使用案例

```c
int main() {
    fd = open("start", O_RDONLY);
    if (fd == -1) {
        errExit("open");
    }
    // open new or existing file for reading and writing, truncating to zero bytes
    // file permissions r+w for owner, none for all others
    fd = open("my_file", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    if (fd == -1) {
        errExit("open");
    }
    // open new or existing file for writing, truncating to zero bytes
    // writes should always append to the end of file
    fd = open("w.log", O_WRONLY | O_CREAT | O_TRUNC | O_APPEND, S_IRUSR | S_IWUSR);
}
```

### 文件访问模式

| 访问模式 | 描述     |
| -------- | -------- |
| O_RDONLY | 只读     |
| O_WRONLY | 只写     |
| O_RDWR   | 可读可写 |

## read

## write

## close

## lseek

## ioctl
