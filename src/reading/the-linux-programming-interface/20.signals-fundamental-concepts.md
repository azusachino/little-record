# Signals: Fundamental Concepts

- The various different signals and their purposes
- the circumstances in which the kernel may generate a signal for a process, and the syscalls that one process may use to send a signal to another process
- how a process responds to a signal by default, and the means by which a process can change its response to a signal
- the use of a process signal mask to block signals, and the associated notion of pending signals
- how a process can suspend execution and wait for the delivery of a signal

## Concepts and Overview

A signal is a notification to a process that an event has occurred. Signals are sometimes described as _software interrupts_. Signals are analogous to hardware interrupts in that they interrupt the normal flow of execution of a program.

Cases that kernel send signals to process:

- A hardware exception occurred, meaning that the hardware detected a fault condition that was notified to the kernel
- The user typed on of the terminal special characters that generate signals
- A software event occurred

Each signal is defined as a unique integer, starting sequentially from 1. (`<signal.h>`, `SIGxxxx`)

A pending signal is not always delivered to a process as soon as it is next scheduled to run.

Upon delivery of a signal, a process carries out one of the following default actions:

- The signal is ignored
- The process is terminated
- A core dump file is generated, and the process is terminated
- The process is stopped-execution of the process is suspended
- Execution of the process is resumed after previously being stopped

## Signal types and default actions

## Changing Signal Dispositions: `signal()`

## Introduction to Signal Handlers

## Sending signals: `kill()`

## Checking for the existence of a process

## Other ways of sending signals: `raise()` and `killpg()`

## Displaying signal descriptions

## Signal Sets

## The signal mask

## Pending signals

## Signals are not queued

## Changing signal dispositions: `sigaction()`

## Waiting for a signal: `pause()`

## Summary

A signal is a notification that some kind of event has occurred, and may be sent to a process by the kernel, by another process, or by itself. There is a range of standard signal types, each of which has a unique number and purpose.

Signal delivery is typically asynchronous, meaning that the point at which the signal interrupts execution of the process is unpredictable. In some cases (hardware-generated signals), signals are delivered synchronously, meaning that delivery occurs predictably and reproducibly at a certain point in the execution of a program.

By default, a signal either is ignored, terminated a process (with or withour a core dump), stops a running process, or restarts a stopped process. The particular default action depends on the signal type. Alternatively, a program can use `signal()` or `sigaction()` to explicitly ignore a signal or to establish a programmer-defined signal handelr function that is invoked when the signal is delivered. For portability reasons, establishing a signal handler is best performed using `sigaction()`.

A process (with suitable permissions) can send signal to another process using `kill()`. Sending the num signal(0) is a way of determining if a particular process ID is in use.

Each process has a signal mask, which is the set of signals whose delivery is currently blocked. Signals can be aded to and removed from the signal mask using `sigprocmask()`.

If a signal is received while it is blocked, then it remains pending until it is unblocked. Standard signals can't be queued; that is, a signal can be marked as pending (and thus later delivered) only once. A process can use the `sigpending()` syscall to retrieve a signal set (a data structure used to represent multiple different signals) identifying the signals that it has pending.

The `sigaction()` syscall provides more control and flexibility than `signal()` when setting the disposition of a signal. First, we can specify a set of additional signals to be blocked when a handler is invoked. In addition, various flags can be used to control the actions that occur when a signal handler is invoked. For example, there are flags that select the older unreliable signal semantics (not blocking the signal causing invocation of a handler, and having the disposition of the signal reset to its default before the handler is called).

Using `pause()`, a process can suspend execution until a signal arrives.
